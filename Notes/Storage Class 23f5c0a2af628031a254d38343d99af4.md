# Storage Class

## âœ… Storage Classes in C

### ğŸ“Œ Summary Table

| Storage Class | Scope | Lifetime | Default Value | Stored In | Addressable |
| --- | --- | --- | --- | --- | --- |
| `auto` | Local | Till block ends | Garbage | RAM | âœ… Yes |
| `register` | Local | Till block ends | Garbage | CPU Register* | âŒ No |
| `static` | Local or File | Entire program | Zero (if uninit) | RAM | âœ… Yes |
| `extern` | Global | Entire program | Zero (if uninit) | RAM | âœ… Yes |

## âœ… Storage Classes in C++

C++ supports the **same 4 storage classes** from C:

| Storage Class | Scope | Lifetime | Default Value | Stored In | Extra in C++ |
| --- | --- | --- | --- | --- | --- |
| `auto` | Local | Till block ends | Garbage (for PODs) | RAM | In C++11+, different meaning (type deduction) |
| `register` | Local | Till block ends | Garbage | CPU Register* | Mostly ignored by modern compilers |
| `static` | Local/File | Entire program | Zero (if uninitialized) | RAM | Works in classes too |
| `extern` | Global | Entire program | Zero (if uninitialized) | RAM | For globals across files |

### ğŸ”¹ 1. `auto` (Modern C++: Type Inference)

- In **C++11 and later**, `auto` means **type deduction**, not storage class.

```cpp
auto x = 5;     // x is int
auto y = 3.14;  // y is double
```

In **C++98**, `auto` was same as C â€” local storage class â€” but this usage is obsolete.

### ğŸ”¹ 2. `register`

- Same as C: Hints to use **CPU register**, but most modern compilers ignore this.

```cpp
register int i = 0;
```

- âš ï¸ You **canâ€™t take address**: `&i` is not allowed.

### ğŸ”¹ 3. `static`

- Same as in C, with added usage in **classes**.
- In functions: retains value across calls.
- In classes: shared by all instances.

```cpp
void countCall() {
    static int count = 0;
    count++;
    std::cout << count << "\n";
}
```

In class:

```cpp
cpp
CopyEdit
class MyClass {
public:
    static int sharedValue;
};

// Must define it outside:
int MyClass::sharedValue = 0;

```

While **`static` in C and C++** share the same **basic meaning** (controlling **lifetime**, **visibility**, and **linkage**), **C++ adds additional uses** of `static`, especially inside **classes** and **OOP constructs**. Let's compare them side by side:

---

## ğŸ” Static in **C vs C++**

| Aspect | C | C++ |
| --- | --- | --- |
| **Function-level static variable** | Retains value across function calls | âœ… Same as in C |
| **Static global variable** | Limits scope to the current file (internal linkage) | âœ… Same as in C |
| **Static in structs** | âŒ Not allowed | âœ… Allowed in classes â€” creates class-wide shared members |
| **Static class member (method or variable)** | âŒ Not applicable (no classes in C) | âœ… Shared across all objects, accessed with `ClassName::member` |
| **Access via object** | âŒ Only functions and variables | âœ… Can access static members via class or object |
| **OOP relevance** | âŒ None | âœ… Major usage in Singleton, utility functions, shared config, etc. |
| **Namespace support** | âŒ No namespaces in C | âœ… Static + namespace gives better encapsulation |

---

## ğŸ”¹ Examples

### âœ… In C

```c
c
CopyEdit
#include <stdio.h>

void counter() {
    static int count = 0;
    count++;
    printf("Count = %d\n", count);
}

int main() {
    counter();  // Count = 1
    counter();  // Count = 2
}

```

```c
c
CopyEdit
// File: a.c
static int hiddenVar = 10;  // Cannot be accessed outside this file

```

---

### âœ… In C++

### ğŸ”¸ Static variable in function (Same as C)

```cpp
cpp
CopyEdit
void counter() {
    static int count = 0;
    count++;
    std::cout << count << std::endl;
}

```

### ğŸ”¸ Static data member in class (âŒ Not in C)

```cpp
cpp
CopyEdit
class MyClass {
public:
    static int shared;
    void show() { std::cout << shared << std::endl; }
};

// Definition outside the class (mandatory)
int MyClass::shared = 42;

int main() {
    MyClass a, b;
    a.show();   // 42
    MyClass::shared = 99;
    b.show();   // 99 (shared across all instances)
}

```

### ğŸ”¸ Static member function (works without `this`)

```cpp
cpp
CopyEdit
class MathUtil {
public:
    static int square(int x) {
        return x * x;
    }
};

int main() {
    std::cout << MathUtil::square(5);  // 25
}

```

---

## ğŸ“Œ Summary

| Use case | C | C++ |
| --- | --- | --- |
| Static function variable | âœ… Yes | âœ… Yes (same behavior) |
| Static global variable | âœ… Yes | âœ… Yes (same behavior) |
| Static inside struct/class | âŒ No | âœ… Yes, shared by all objects |
| Static member function | âŒ No | âœ… Yes, no `this`, can be called via class |
| Access via class | âŒ No | âœ… Yes (ClassName::staticMember) |

### ğŸ”¹ 4. `extern`

- Used to **declare global variables/functions** from another file.

```cpp
// In file1.cpp
int globalX = 42;

// In file2.cpp
extern int globalX;
```

## ğŸ†• Extra Concepts in C++ (not strictly storage classes but related)

| Feature | Description |
| --- | --- |
| `mutable` | Allows a member to be modified even in `const` object |
| `thread_local` | C++11: Each thread has its own instance |
| `static` in class | Shared by all objects, can be called via class name |

Example of `thread_local`:

```cpp
thread_local int count = 0;  // each thread gets its own `count`
```

---

### ğŸ“Œ Summary Table

| Storage Class | Lifetime | Scope | Default Value | Notes |
| --- | --- | --- | --- | --- |
| `auto` | Block | Local | Depends | Type inference (from C++11) |
| `register` | Block | Local | Garbage | Address not accessible (`&` not allowed) |
| `static` | Entire program | Local or Class | Zero if uninit | Retains value across function calls |
| `extern` | Entire program | Global | Zero if uninit | Declares existing symbol from another file |
| `thread_local` | Lifetime of thread | Local/Global | Zero if uninit | One copy per thread (C++11 and later) |