# Storage Class

## ✅ Storage Classes in C

### 📌 Summary Table

| Storage Class | Scope | Lifetime | Default Value | Stored In | Addressable |
| --- | --- | --- | --- | --- | --- |
| `auto` | Local | Till block ends | Garbage | RAM | ✅ Yes |
| `register` | Local | Till block ends | Garbage | CPU Register* | ❌ No |
| `static` | Local or File | Entire program | Zero (if uninit) | RAM | ✅ Yes |
| `extern` | Global | Entire program | Zero (if uninit) | RAM | ✅ Yes |

## ✅ Storage Classes in C++

C++ supports the **same 4 storage classes** from C:

| Storage Class | Scope | Lifetime | Default Value | Stored In | Extra in C++ |
| --- | --- | --- | --- | --- | --- |
| `auto` | Local | Till block ends | Garbage (for PODs) | RAM | In C++11+, different meaning (type deduction) |
| `register` | Local | Till block ends | Garbage | CPU Register* | Mostly ignored by modern compilers |
| `static` | Local/File | Entire program | Zero (if uninitialized) | RAM | Works in classes too |
| `extern` | Global | Entire program | Zero (if uninitialized) | RAM | For globals across files |

### 🔹 1. `auto` (Modern C++: Type Inference)

- In **C++11 and later**, `auto` means **type deduction**, not storage class.

```cpp
auto x = 5;     // x is int
auto y = 3.14;  // y is double
```

In **C++98**, `auto` was same as C — local storage class — but this usage is obsolete.

### 🔹 2. `register`

- Same as C: Hints to use **CPU register**, but most modern compilers ignore this.

```cpp
register int i = 0;
```

- ⚠️ You **can’t take address**: `&i` is not allowed.

### 🔹 3. `static`

- Same as in C, with added usage in **classes**.
- In functions: retains value across calls.
- In classes: shared by all instances.

```cpp
void countCall() {
    static int count = 0;
    count++;
    std::cout << count << "\n";
}
```

In class:

```cpp
cpp
CopyEdit
class MyClass {
public:
    static int sharedValue;
};

// Must define it outside:
int MyClass::sharedValue = 0;

```

While **`static` in C and C++** share the same **basic meaning** (controlling **lifetime**, **visibility**, and **linkage**), **C++ adds additional uses** of `static`, especially inside **classes** and **OOP constructs**. Let's compare them side by side:

---

## 🔁 Static in **C vs C++**

| Aspect | C | C++ |
| --- | --- | --- |
| **Function-level static variable** | Retains value across function calls | ✅ Same as in C |
| **Static global variable** | Limits scope to the current file (internal linkage) | ✅ Same as in C |
| **Static in structs** | ❌ Not allowed | ✅ Allowed in classes — creates class-wide shared members |
| **Static class member (method or variable)** | ❌ Not applicable (no classes in C) | ✅ Shared across all objects, accessed with `ClassName::member` |
| **Access via object** | ❌ Only functions and variables | ✅ Can access static members via class or object |
| **OOP relevance** | ❌ None | ✅ Major usage in Singleton, utility functions, shared config, etc. |
| **Namespace support** | ❌ No namespaces in C | ✅ Static + namespace gives better encapsulation |

---

## 🔹 Examples

### ✅ In C

```c
c
CopyEdit
#include <stdio.h>

void counter() {
    static int count = 0;
    count++;
    printf("Count = %d\n", count);
}

int main() {
    counter();  // Count = 1
    counter();  // Count = 2
}

```

```c
c
CopyEdit
// File: a.c
static int hiddenVar = 10;  // Cannot be accessed outside this file

```

---

### ✅ In C++

### 🔸 Static variable in function (Same as C)

```cpp
cpp
CopyEdit
void counter() {
    static int count = 0;
    count++;
    std::cout << count << std::endl;
}

```

### 🔸 Static data member in class (❌ Not in C)

```cpp
cpp
CopyEdit
class MyClass {
public:
    static int shared;
    void show() { std::cout << shared << std::endl; }
};

// Definition outside the class (mandatory)
int MyClass::shared = 42;

int main() {
    MyClass a, b;
    a.show();   // 42
    MyClass::shared = 99;
    b.show();   // 99 (shared across all instances)
}

```

### 🔸 Static member function (works without `this`)

```cpp
cpp
CopyEdit
class MathUtil {
public:
    static int square(int x) {
        return x * x;
    }
};

int main() {
    std::cout << MathUtil::square(5);  // 25
}

```

---

## 📌 Summary

| Use case | C | C++ |
| --- | --- | --- |
| Static function variable | ✅ Yes | ✅ Yes (same behavior) |
| Static global variable | ✅ Yes | ✅ Yes (same behavior) |
| Static inside struct/class | ❌ No | ✅ Yes, shared by all objects |
| Static member function | ❌ No | ✅ Yes, no `this`, can be called via class |
| Access via class | ❌ No | ✅ Yes (ClassName::staticMember) |

### 🔹 4. `extern`

- Used to **declare global variables/functions** from another file.

```cpp
// In file1.cpp
int globalX = 42;

// In file2.cpp
extern int globalX;
```

## 🆕 Extra Concepts in C++ (not strictly storage classes but related)

| Feature | Description |
| --- | --- |
| `mutable` | Allows a member to be modified even in `const` object |
| `thread_local` | C++11: Each thread has its own instance |
| `static` in class | Shared by all objects, can be called via class name |

Example of `thread_local`:

```cpp
thread_local int count = 0;  // each thread gets its own `count`
```

---

### 📌 Summary Table

| Storage Class | Lifetime | Scope | Default Value | Notes |
| --- | --- | --- | --- | --- |
| `auto` | Block | Local | Depends | Type inference (from C++11) |
| `register` | Block | Local | Garbage | Address not accessible (`&` not allowed) |
| `static` | Entire program | Local or Class | Zero if uninit | Retains value across function calls |
| `extern` | Entire program | Global | Zero if uninit | Declares existing symbol from another file |
| `thread_local` | Lifetime of thread | Local/Global | Zero if uninit | One copy per thread (C++11 and later) |